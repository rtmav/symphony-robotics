{"compilerOptions":{"css":"external","dev":true,"hydratable":true},"configFile":false,"extensions":[".svelte"],"preprocess":[{"markup":"async markup({content:b,filename:c}){if(utils_1.isFn(a)&&(3<=SVELTE_MAJOR_VERSION&&console.warn(\"[svelte-preprocess] For svelte >= v3, instead of onBefore(), prefer to prepend a preprocess object to your array of preprocessors\"),b=await a({content:b,filename:c})),g.replace){const a=await utils_1.runTransformer(\"replace\",g.replace,{content:b,filename:c});b=a.code}const d=b.match(h);if(!d)return{code:b};const[e,f,i]=d,j=f.split(/\\s+/).filter(Boolean).reduce((a,b)=>{const[c,d]=b.split(\"=\");return a[c]=!d||d.replace(/['\"]/g,\"\"),a},{});let{code:k,map:l,dependencies:n}=await m({content:i,attributes:j,filename:c});return k=b.slice(0,d.index)+k+b.slice(d.index+e.length),{code:k,map:l,dependencies:n}}","script":"async script({content:a,attributes:b,filename:c}){const d=await k({content:a,attributes:b,filename:c});if(null==d)return;let{code:e,map:f,dependencies:h,diagnostics:i}=d;if(g.babel){const a=await utils_1.runTransformer(\"babel\",g.babel,{content:e,map:f,filename:c});e=a.code,f=a.map,h=utils_1.concat(h,a.dependencies),i=utils_1.concat(i,a.diagnostics)}return{code:e,map:f,dependencies:h,diagnostics:i}}","style":"async style({content:a,attributes:b,filename:c}){const d=await l({content:a,attributes:b,filename:c});if(null==d)return;let{code:e,map:f,dependencies:h}=d;if(g.postcss){const a=await utils_1.runTransformer(\"postcss\",g.postcss,{content:e,map:f,filename:c});e=a.code,f=a.map,h=utils_1.concat(h,a.dependencies)}if(b.global){const a=await utils_1.runTransformer(\"globalStyle\",null,{content:e,map:f,filename:c});e=a.code,f=a.map}return{code:e,map:f,dependencies:h}}"},{"script":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tif (basename.startsWith('+page.') || basename.startsWith('+layout.')) {\n\t\t\tconst match = content.match(options_regex);\n\t\t\tif (match) {\n\t\t\t\tconst fixed = basename.replace('.svelte', '(.server).js/ts');\n\n\t\t\t\tconst message =\n\t\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t\t`\\`${match[1]}\\` will be ignored — move it to ${fixed} instead. See https://kit.svelte.dev/docs/page-options for more information.`;\n\n\t\t\t\tif (!warned.has(message)) {\n\t\t\t\t\tconsole.log(message);\n\t\t\t\t\twarned.add(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","markup":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tif (basename.startsWith('+layout.') && !content.includes('<slot')) {\n\t\t\tconst message =\n\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t'`<slot />` missing — inner content will not be rendered';\n\n\t\t\tif (!warned.has(message)) {\n\t\t\t\tconsole.log(message);\n\t\t\t\twarned.add(message);\n\t\t\t}\n\t\t}\n\t}"}]}